{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Pseudovote is a voting machine implementing the simplest process of casting pseudonymous votes on a public bulletin board. Voting takes place in three steps:</p> <ol> <li>Deliver dedicated pseudonyms to a list of e-mails;</li> <li>Collect the votes on a public bulletin board;</li> <li>Count the result in a reasonably secret ballot.</li> </ol> <p>Minimalist setting for public bulletin board voting is reinforced by using common tools like e-mail and pseudonyms, but also immediate auditability of submitting your vote to a real time bulletin board, where you can literally see other votes coming in.</p> <p>Pseudovote moves in opposite direction to complicated voting systems with state of art cryptography, aiming instad to make the process understandable for every participant. Even the web service in its current form is meant as a prototype for testing and educational use, which should be replaced with plain text append only bulletin board for more demanding use cases.</p>"},{"location":"#in-real-life","title":"In real life","text":"<p>Preliminary forms of Pseudovote have been used at:</p> <ul> <li>Wikimedia Estonia General Assembly (2020)</li> <li>Estonian Green Party General Assembly (2022)</li> </ul>"},{"location":"#running-your-own","title":"Running your own","text":"<p>1. Download the source code</p> <pre><code>git clone https://github.com/infoaed/pseudovote.git\ncd pseudovote\npip install -r requirements.txt\n</code></pre> <p>2. Set up the database</p> <pre><code>sudo apt install postgresql\nsudo -u postgres psql &lt; database.sql\n</code></pre> <p>3. Run the bulletin board</p> <pre><code>uvicorn pseudovote.service:app\n</code></pre> <p>The web service should be running at localhost:8000.</p>"},{"location":"api/","title":"API documentation","text":"async <code>pseudovote.service.startup</code>() <p>Initialize app.</p> async <code>pseudovote.service.shutdown</code>() <p>Shut everything down as gracefully as possible.</p> class <code>pseudovote.service.poll_choices</code>(title='', min=0, max=1, choices=None, ordered=False) <p>Convenience data structure to keep those crazy regexes beside the poll options data itself.</p> class <code>pseudovote.service.VoteRejectException</code>(message) <p>Dedicated exception for vote processing to simplify the logic.</p> <code>pseudovote.service.get_pseudonym_list</code>(voter_count, word_list, cryptonyms=False, salt_amount=None) <p>Creating the randomized list of pseudonyms was initially the main feature of initial Uduloor version of pseudonymous voting routine, but it is currently provided here mostly for convenience. Ideally you should select the pseudonyms far away from the bulletin board service in order to avoid any manipulation of the votes. Selection process currently enables of selection pseudonyms and \"salting\" them with a number to create memorizable pairs of text and numbers following the pattern of <code>user123</code>. In a real polling situation you should provide pseudonyms separately and then maybe include hashed list of pseudonyms as gatekeeper for vote collecting mechanism to make sure it is not manipulated by spamming or similar.</p> <code>pseudovote.service.announce_event</code>(name, timestamp, channel, started=None) <p>Announce events to every client in channel.</p> <code>pseudovote.service.announce_event_individual</code>(name, timestamp, cq, channel, started=None) <p>Announce already past events for individual clients mostly on connecting the feed.</p> <code>pseudovote.service.event_publisher</code>(req, channel, cq, start, end, encrypt_ballots=False) <p>Each client will have this publisher loop that will self destruct on disconnect. If no clients are listening to specifig election feed any more, the channel itself will be removed.</p> <code>pseudovote.service.database_listener</code>(*args) <p>Listens to database notifications and relays the messages to designated channels. There is one notfication service for all the votings in order to keep the connection pool minimal.</p> async <code>pseudovote.service.subscribe_bulletin</code>(req) <p>Bulletin board of incoming votes is an essential feature and is displayed based on <code>token</code> of a poll. The feed is provided as EventSource feed in JSON and includes also poll status announcements.</p> <code>pseudovote.service.convert_to_token</code>(name) <p>Convert name to a slug. Maybe should replace with dedicated slugify module.</p> async <code>pseudovote.service.get_bulletin_token</code>(req) <p>Coordinate available tokens with database.</p> async <code>pseudovote.service.get_bulletin_name</code>(req) <p>Coordinate available names with database.</p> <code>pseudovote.service.data_state</code>(label, data={}, token='?') <p>Content of data events about voting progress generated by the main voting process routine.</p> async <code>pseudovote.service.start_voting</code>(req) <p>Web entry point for creating a poll/an election.</p> <code>pseudovote.service.conduct_voting_process</code>(req, body=None) <p>Tha main voting process routine will run on server until the voting is over and will provide real time data feed in EventSource format on audit dashboard. The feed consists of JSON formatted notes about changes in poll status. It takes POST request body as imput, if no request body is provided it will attempt to catch up with feed of already existing poll based on <code>token</code> parameter of request. Technically poll can fail if <code>create_poll</code> is not reached or successfully executed, but after that the process will run on autopilot up the end of voting process. If the connection is terminally dropped for some reason, one can connect to public audit dashboard <code>https://voting.host/audit/{token}</code> or using JSON event feed to continue auditing the process, which will provide you the same data except sent e-mails report, which is currently specific to the viewpoint of the creator of the poll.</p> async <code>pseudovote.service.create_poll</code>(title=None, token=None, name=None, start_time=None, end_time=None, choices=None, voterhash_type=None, ballot_type=None, reject_multi=None, personal_ballot=None, limit_choices=None, reject_invalid=None, reject_unlisted=None, mute_unlisted=None, block_unlisted=None, limit_invalid=None, limit_unlisted=None, limit_multi=None, encrypt_ballots=None, voter_count=None) <p>Register a poll in database.</p> async <code>pseudovote.service.provide_voterlist_to_bulletin</code>(pseudo_list, voterhash_type=None, bulletin_id=None) <p>Create voterlist for the poll in case <code>provide_voterlist</code> has been selected among bulletin board restrictions. Otherwise the voterlist will be not recorded to database, except for emergency fallback (see <code>encrypt_voterlist_under_embargo</code>).</p> async <code>pseudovote.service.encrypt_voterlist_under_embargo</code>(pseudo_list, use_public_key, pubkey_id, bulletin_id) <p>Encrypting voterlist is done on demand with pgp public key provided at <code>use_public_key</code> in bulletin board access restrictions dialog or as a fallback when system breaks down for some reason. If voterlist is encrypted as a fallback, public key of the bulletin board system itself is used in order to decrypt the voterlist with private key after embargo, that is, when the election is over. Currently encrypting the voterlist is not proper feature of exemplified voting scheme, because encryping voterlist makes sense if it is done as completely separate process and maybe providing voterlist to bulletin board in already encrypted form (hashed pseydonyms and/or full encrypted voterlist to be decrypted after election is over).</p> async <code>pseudovote.service.get_ballot_count</code>(bulletin_id) <p>Report ballot count for a poll/election.</p> async <code>pseudovote.service.collector</code>(req) <p>Vote collector is a web page where votes are collected for single pre-defined election. Election status and bulletin board of incoming votes are displayed in real time to provide voter transparancy and hands on understanding of the process. Vote collector is the most critical part of the system from viewpoint of technical universality and has to be usable without Javascript or any other fancy web technology. Currently vote collector is somewhat tested against HTTPS capable versions of Lynx, Netscape Navigator and different versions Android/iPhone.</p> async <code>pseudovote.service.votes_until_now</code>(token=None, bulletin_id=None, start=None, end=None, encrypt_ballots=None) <p>Displays bulletin board in TEXT format up to current moment. This is used as an easy way to display bulletin board history in vote collector TEXTAREA without extra work on client side, maybe ideally should be replaced with feeding the events from certain point in history and ensuring there are no gaps in bulletin board.</p> async <code>pseudovote.service.data_for_bulletin_feed</code>(token) <p>If conduct election process is disturbed, this enables to condtinue observers still getting the needed audit information in the end of election. This is mostly for convenience and fallback to ensure continuity of the process in case of milder technical disturbances.</p> async <code>pseudovote.service.data_for_bulletin</code>(token=None, bulletin_id=None, pseudonym='') <p>Returns basic data for displaying election for a voter or an auditor in vote collector web page or audit web page. Also formats the choices in HTML if they are predefined.</p> async <code>pseudovote.service.is_in_voterlist</code>(con, voterhash_type, bulletin_id, pseudonym) <p>Convenience method to detect if pseudonym is in voterlist.</p> <code>pseudovote.service.conforms_to_choices</code>(ballot, c) <p>If creator of elections has selected to refrain from storing invalid ballots, this is used to fuzzy match them to provided voter choices.</p> <code>pseudovote.service.normalize_ballot_text</code>(text) <p>Currently only replaces newlines with backslashes for better readability in the context of plain text bulletin board.</p> async <code>pseudovote.service.process_vote</code>(req) <p>Makes sense of the submitted vote and returns a receipt. This is heavily based on restrictions defined by creator of the poll. Normally the receipt is returned as JSON, but for explicitly defined noscript clients HTML page with receipt is displayed instead. Most of this playing with restrictions is educational and shouldn't be used in normal small scale elections where people trust each other enough to not opt for exhaustive technical manipulations.</p> async <code>pseudovote.service.distributor_home</code>(req) <p>This is a home page for bulletin board, currently enabling to create an election for educational or testing purposes, ideally should be accepting voterlist hashes or similar for elections already defined elsewhere.</p> async <code>pseudovote.service.audit_bulletin</code>(req) <p>Opens independent audit feed for an election where auditors will be provided data needed to audit the elections of tally the votes. The data displayed is the same displayed on the main election process dashboard except the e-mail sending process.</p> async <code>pseudovote.service.sitemap</code>(req) <p>Dynamically generated sitemap.</p> async <code>pseudovote.service.robots</code>(req) <p>Dynamically generated robots.txt.</p> <code>pseudovote.service.get_json_metadata</code>(req, name, alt_name, title, description, params={}, page='home') <p>Provide schema.org style JSON-LD metadata.</p> <code>pseudovote.service.metadata_for_home</code>(req, name, alt_name, title, description) <p>JSON-LD metadata for home.</p> <code>pseudovote.service.metadata_for_bulletin</code>(req, name, alt_name, title, description, params) <p>JSON-LD metadata for bulletin boards.</p> <code>pseudovote.service.metadata_for_audit</code>(req, name, alt_name, title, description, params) <p>JSON-LD metadata for audit dashboards.</p> async <code>pseudovote.service.select_locale_by_force</code>(req) <p>Override negotiated locale with the one in URL.</p> <code>pseudovote.service.locale_in_path</code>(req) <p>Detect locale specifiec in URL.</p> async <code>pseudovote.service.serve_i18n_javacript</code>(req) <p>Since Javascript i18n is always painful, just cut the Gordian knot with serving scripts as translatable templates.</p> async <code>pseudovote.service.get_app_stats</code>(req) <p>Display some general information about system status at <code>/api/stats</code>.</p> <code>pseudovote.util.read_lines</code>(filename, ignore=False) <p>Read text file into list, if no file, return empty list.</p> <code>pseudovote.util.to_list</code>(body, key) <p>Convert request body to list instead of text with newlines.</p> <code>pseudovote.util.datetime_representation</code>(dt=None) <p>Convert datetime into format that Javascript reads with timezone etc.</p> async <code>pseudovote.util.wait_until</code>(stop) <p>Sleep until next move is needed.</p> <code>pseudovote.util.run_at</code>(dt, callback, *args) <p>Create coroutine starting at certain moment.</p> <code>pseudovote.util.already_passed</code>(stop) <p>If the moment has already passed.</p> <code>pseudovote.util.create_choice_html</code>(r, index, classname, typename, ordered=False) <p>Create HTML for displaying choices on vote collecting web page (in conjunction with <code>templates/collect.js</code>).</p>"}]}